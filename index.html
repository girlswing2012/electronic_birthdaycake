<script>
const ACCESS_CODE = "20260224"; // ä½ è®¾ä¸€ä¸ª

const input = prompt("è¯·è¾“å…¥è®¿é—®å£ä»¤");
if (input !== ACCESS_CODE) {
  document.body.innerHTML = "<h2 style='color:white;text-align:center;margin-top:40vh;'>æ— æƒè®¿é—®</h2>";
}
</script>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Happy Birthday - Starry Glow Edition</title>
    <!-- å¼•å…¥ä¼˜é›…å­—ä½“ -->
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Noto+Sans+SC:wght@300;500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    
    <!-- MediaPipe Hands CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <style>
        :root {
            --primary-glow: #ff66cc;
            --secondary-glow: #cc66ff;
            --text-color: #ffd6f0;
            --holographic: linear-gradient(135deg, rgba(255,111,174,0.4) 0%, rgba(207,168,255,0.4) 50%, rgba(112,214,255,0.4) 100%);
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'Noto Sans SC', sans-serif;
            color: var(--text-color);
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #input-video {
            position: fixed;
            top: 0;
            left: 0;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
        }

        #header-area {
            position: fixed;
            top: 6vh;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            z-index: 100;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        h1 {
            font-family: 'Great Vibes', cursive;
            font-size: clamp(3rem, 10vw, 6rem);
            margin: 0;
            opacity: 0;
            text-shadow: 0 0 15px var(--primary-glow), 0 0 30px var(--secondary-glow);
            transition: opacity 2s ease;
        }

        .sub-text-right {
            position: absolute;
            right: 10%;
            top: 60%;
            font-size: 0.8rem;
            letter-spacing: 4px;
            opacity: 0.4;
            text-transform: uppercase;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .interactive { pointer-events: auto; }

        .btn-magic {
            background: rgba(255, 102, 204, 0.15);
            border: 1px solid var(--primary-glow);
            color: var(--text-color);
            padding: 12px 35px;
            font-size: 1.1rem;
            border-radius: 50px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(255, 102, 204, 0.2);
            margin-top: 20px;
        }

        .btn-magic:hover {
            background: rgba(255, 102, 204, 0.4);
            box-shadow: 0 0 35px var(--primary-glow);
            transform: scale(1.05);
        }

        #blow-meter {
            width: 200px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin-top: 300px;
            display: none;
            overflow: hidden;
        }
        #blow-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, var(--secondary-glow), var(--primary-glow));
            box-shadow: 0 0 10px var(--primary-glow);
        }

        #countdown {
            font-size: 8rem;
            font-weight: bold;
            display: none;
            color: var(--text-color);
            text-shadow: 0 0 40px var(--primary-glow);
            z-index: 200;
        }

        /* å…¨æ¯è´ºå¡ä¸»ä½“ */
        #holographic-card {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 360px;
            min-height: 460px;
            background: var(--holographic);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 30px;
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 40px 30px;
            box-shadow: 0 20px 80px rgba(0,0,0,0.8);
            z-index: 1000;
            text-align: center;
            opacity: 0;
            pointer-events: none;
        }

        #holographic-card::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 30px;
            padding: 2px;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.6), transparent);
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask-composite: exclude;
            pointer-events: none;
        }

        .card-to { font-size: 1.2rem; margin-bottom: 20px; opacity: 0.8; letter-spacing: 2px; }
        .card-wish { font-size: 1rem; line-height: 1.8; margin: 15px 0; font-weight: 300; }
        .card-from { margin-top: auto; font-size: 0.85rem; opacity: 0.6; }

        #gallery-hint {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.85rem;
            letter-spacing: 2px;
            opacity: 0;
            z-index: 100;
            pointer-events: none;
            background: rgba(0,0,0,0.5);
            padding: 8px 24px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
            transition: opacity 0.5s;
        }

        /* é‡æ–°æ‰“å¼€è´ºå¡çš„æŒ‰é’® */
        #show-card-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 1100;
            display: none;
            background: rgba(255, 102, 204, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 20px;
            border-radius: 50px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            font-size: 0.9rem;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        #show-card-btn:hover {
            background: rgba(255, 102, 204, 0.4);
            transform: translateY(-3px);
        }

        .close-card {
            position: absolute;
            top: 20px;
            right: 20px;
            cursor: pointer;
            width: 30px;
            height: 30px;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }
    </style>
</head>
<body>

    <!-- æ·»åŠ èƒŒæ™¯éŸ³ä¹ -->
   <audio id="bgm" loop preload="auto">
  <source src="happy_birthday.mp3" type="audio/mpeg">
</audio>

    <div id="canvas-container"></div>
    <video id="input-video" playsinline></video>

    <div id="header-area">
        <h1 id="title">Happy Birthday</h1>
        <div class="sub-text-right">Best Wishes For You</div>
    </div>

    <div id="ui-layer">
        <div id="intro-screen">
            <button class="btn-magic interactive" style="margin-top: 320px;" onclick="startSequence()">å¼€å¯è¿™ä»½æ˜Ÿå…‰ç¤¼ç‰©</button>
        </div>
        <div id="countdown"></div>
        <div id="interaction-ui">
            <div id="blow-meter"><div id="blow-fill"></div></div>
            <div id="status-msg" class="status-text" style="margin-top:15px; font-size:0.9rem; opacity:0.7;"></div>
            <button id="skip-btn" class="btn-magic interactive" style="display:none; font-size: 0.85rem; margin-top: 40px;" onclick="forceBlowDone()">âœ¨ è®©æ˜Ÿå…‰æ›¿ä½ å®Œæˆè¿™ä¸€åˆ»</button>
        </div>
        <div id="gallery-hint">æŒ¥æ‰‹æ—‹è½¬æ˜Ÿçƒï¼Œæåˆæ”¾å¤§ç…§ç‰‡</div>
        <button id="enable-hands-btn"
        class="btn-magic interactive"
        style="display:none; font-size:0.9rem; margin-top:12px;"
        onclick="enableHandsFromUserGesture()">
  ğŸ“· å¯ç”¨æ‰‹åŠ¿äº’åŠ¨ï¼ˆéœ€è¦ç›¸æœºæƒé™ï¼‰
</button>
    </div>

    <div id="holographic-card" class="interactive">
        <div class="close-card" onclick="hideCardOverlay()">âœ•</div>
        <div class="card-to" id="card-to">To: äº²çˆ±çš„ä½ </div>
        <div class="card-wish" id="card-wish"></div>
        <div class="card-from">From: MJ<br><span id="current-date"></span></div>
        <button class="btn-magic" style="margin-top: 25px; font-size: 0.8rem; padding: 8px 20px;" onclick="restartPage()">é‡æ–°æ’­æ”¾</button>
    </div>

    <button id="show-card-btn" class="interactive" onclick="showCardOverlay()">æŸ¥çœ‹è´ºå¡ âœ¨</button>

    <input id="photo-input" type="file" accept="image/*" multiple style="display:none">

    <script>
        const config = {
            recipientName: "äº²çˆ±çš„ä½ ",
            messageLines: [
		"ä¸Šå¤©å‚å…‰å…®äºˆä»¥é’æ˜¥ï¼Œä»Šæ—¥ä½•æ—¥å…®å…±æ­¤è‰¯è¾°ã€‚",
                "æ„¿ä½ æ­¤åè·¯é€”ï¼Œæ€»æœ‰æ˜Ÿè¾°æŒ‡å¼•ã€‚",
                "æ¯ä¸€åˆ»æœŸå¾…éƒ½èƒ½å¦‚æœŸè€Œè‡³ï¼Œ",
                "æ¯ä¸€ä»½åŠªåŠ›éƒ½èƒ½è¢«å²æœˆåšå¾…ã€‚",
                "å¹´å¹´å²å²ï¼Œå¹³å®‰å–œä¹ï¼"
            ],
            photoList: [],
            blowHoldSeconds: 2.0,
            blowThreshold: 0.12,
            particleQuality: "high",
            theme: {
                background: "#000000",
                rosePink: "#FF6FAE",
                lavender: "#CFA8FF"
            },
            gesture: {
                swipeSensitivity: 1.2, 
                pinchThreshold: 0.4,
                kFrames: 5,           
                cooldown: 650         
            }
        };

        const State = {
            INTRO: 'INTRO',
            COUNTDOWN: 'COUNTDOWN',
            CAKE_REVEAL: 'CAKE_REVEAL',
            BLOW: 'BLOW',
            EXTINGUISH: 'EXTINGUISH',
            GIFT: 'GIFT',
            CARD_PHOTOS: 'CARD_PHOTOS'
        };

        let currentState = State.INTRO;
        let scene, camera, renderer, clock;
        let starField, cakeGroup, giftBox;
        let galleryGroup, photoCards = [], sphereParticles;
        let candles = [], flames = [];
        let analyser, dataArray, audioContext;
        let blowProgress = 0;
        let currentPhotoIndex = 0;
        let targetRotation = 0;
        let isDragging = false, startX = 0;
        let autoRotate = true, lastInteractTime = 0;
        let isCardExpanded = false;

        let wristHistory = [];
        let gestureCooldown = 0;
        let smoothPinchDist = 1.0;
        let isPinching = false;
        let fistCounter = 0, palmCounter = 0;
        // ===== æ‰‹åŠ¿äº¤äº’å¢å¼ºï¼šæ–°å¢å…¨å±€çŠ¶æ€ï¼ˆåªå½±å“æ‰‹åŠ¿éƒ¨åˆ†ï¼‰ =====
        let lastWristX = 0;               // ä½ ä»£ç é‡Œç”¨åˆ°äº†ä½†æ²¡å®šä¹‰
        let smoothedDx = 0;               // å¹³æ»‘æ—‹è½¬
	let selectedCard = null;          // å½“å‰è¢«æåˆé€‰ä¸­çš„ç…§ç‰‡å¡ç‰‡
	let selectedHome = null;          // é€‰ä¸­å‰çš„ä½ç½®/ç¼©æ”¾
	let pinchHold = 0;                // æåˆç¨³å®šå¸§æ•°
	let palmHold = 0;                 // å¼ å¼€æ‰‹æŒç¨³å®šå¸§æ•°
	let fistHold = 0;                 // åˆæ‹¢æ‰‹åŠ¿ç¨³å®šå¸§æ•°
	let isPalmZoomed = false;         // æ˜¯å¦å¤„äºâ€œå¼ å¼€æ‰‹æŒæ”¾å¤§æ€â€
	const raycasterHand = new THREE.Raycaster();
	const ndcHand = new THREE.Vector2();

        let mpHands, mpCamera;

        function initThree() {
            if (scene) return;
            scene = new THREE.Scene();
            scene.background = new THREE.Color(config.theme.background);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.8, 6.5);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            clock = new THREE.Clock();
            createStarField();
	const amb = new THREE.AmbientLight(0xffffff, 0.9);
	scene.add(amb);
	const dir = new THREE.DirectionalLight(0xffffff, 0.9);
	dir.position.set(2, 4, 6);
	scene.add(dir);
            initInteractionListeners();
            window.addEventListener('resize', onWindowResize);
        }

        function createStarField() {
            const count = 8000;
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(count * 3);
            const cols = new Float32Array(count * 3);
            for(let i=0; i<count; i++) {
                pos[i*3] = (Math.random()-0.5)*30;
                pos[i*3+1] = (Math.random()-0.5)*30;
                pos[i*3+2] = (Math.random()-0.5)*30;
                const c = new THREE.Color(Math.random()>0.5?config.theme.rosePink:config.theme.lavender);
                cols[i*3]=c.r; cols[i*3+1]=c.g; cols[i*3+2]=c.b;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(cols, 3));
            starField = new THREE.Points(geo, new THREE.PointsMaterial({ size: 0.04, vertexColors: true, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending }));
            scene.add(starField);
        }

// ===== æœ¬åœ°ç…§ç‰‡åŠ è½½ï¼šå¯¹æ–¹é€‰æ‹©åæ‰æ˜¾ç¤ºï¼ˆä¸ä¸Šä¼ ã€ä¸å‡ºç½‘ï¼‰=====
let localPhotoObjectURLs = [];

function revokeLocalPhotoURLs() {
  localPhotoObjectURLs.forEach(u => URL.revokeObjectURL(u));
  localPhotoObjectURLs = [];
}

// æ¸…ç†æ—§ç›¸å†Œï¼ˆé¿å…é‡å¤åˆ›å»º/å†…å­˜æ³„æ¼ï¼‰
function disposeGallery() {
  if (!galleryGroup) return;

  galleryGroup.traverse((obj) => {
    if (obj.isMesh && obj.material) {
      if (obj.material.map) {
        obj.material.map.dispose();
        obj.material.map = null;
      }
      obj.material.dispose && obj.material.dispose();
    }
    if (obj.geometry) obj.geometry.dispose && obj.geometry.dispose();
  });

  scene.remove(galleryGroup);
  galleryGroup = null;
  photoCards = [];
  sphereParticles = null;
}

function requestLocalPhotos() {
  return new Promise((resolve, reject) => {
    const input = document.getElementById('photo-input');
    if (!input) return reject(new Error("photo-input not found"));

    // é‡ç½®ï¼Œç¡®ä¿åŒä¸€æ‰¹ç…§ç‰‡é‡å¤é€‰æ‹©ä¹Ÿä¼šè§¦å‘ change
    input.value = "";

    input.onchange = () => {
      const files = Array.from(input.files || []).filter(f => f.type.startsWith("image/"));
      if (!files.length) return reject(new Error("no files selected"));

      // é‡Šæ”¾ä¸Šæ¬¡çš„ objectURL
      revokeLocalPhotoURLs();

      const urls = files.map(f => {
        const u = URL.createObjectURL(f);
        localPhotoObjectURLs.push(u);
        return u;
      });

      resolve(urls);
    };

    // å¿…é¡»ç”±ç”¨æˆ·æ‰‹åŠ¿è§¦å‘ï¼ˆä½ åœ¨ openGift ç‚¹å‡»é‡Œè§¦å‘ï¼Œç¬¦åˆï¼‰
    input.click();
  });
}


        function createPhotoGallery() {
            galleryGroup = new THREE.Group();
            galleryGroup.position.set(0, 1.2, 0);
            galleryGroup.visible = false;
            scene.add(galleryGroup);

            const radius = 3.2;
            const count = config.photoList.length;
            const loader = new THREE.TextureLoader();
            const phi = Math.PI * (3 - Math.sqrt(5)); 

            const pCount = 2500;
            const pGeo = new THREE.BufferGeometry();
            const pPos = new Float32Array(pCount * 3);
            for(let i=0; i<pCount; i++) {
                const lon = Math.random() * Math.PI * 2;
                const lat = Math.acos(Math.random() * 2 - 1);
                pPos[i*3] = radius * Math.sin(lat) * Math.cos(lon);
                pPos[i*3+1] = radius * Math.sin(lat) * Math.sin(lon);
                pPos[i*3+2] = radius * Math.cos(lat);
            }
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
            sphereParticles = new THREE.Points(pGeo, new THREE.PointsMaterial({
                size: 0.035, color: config.theme.lavender, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending
            }));
            galleryGroup.add(sphereParticles);

            config.photoList.forEach((path, i) => {
                const cardG = new THREE.Group();
                const y = 1 - (i / (count - 1)) * 2;
                const rAtY = Math.sqrt(1 - y * y);
                const theta = phi * i;
                
                let px = Math.cos(theta) * rAtY * radius;
                let py = y * radius;
                let pz = Math.sin(theta) * rAtY * radius;

                if (px > 0.5 && py > 0.5 && pz > 0) {
                    px -= 1.0; py -= 1.0;
                }
                
                cardG.position.set(px, py, pz);

                const mesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(1.6 * 0.7, 1.2 * 0.7), 
                    new THREE.MeshBasicMaterial({ color: 0x222222, side: THREE.DoubleSide, transparent: true, opacity: 0.9 })
                );
                
                loader.load(path, (tex) => {
                    mesh.material.map = tex;
                    mesh.material.color.set(0xffffff);
                    mesh.material.needsUpdate = true;
                });

                const border = new THREE.LineSegments(
                    new THREE.EdgesGeometry(new THREE.PlaneGeometry(1.15, 0.87)),
                    new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 })
                );
                
                cardG.add(mesh, border);
                galleryGroup.add(cardG);
                photoCards.push(cardG);
            });
        }

        /**
         * æ ¸å¿ƒäº¤äº’é€»è¾‘
         */
        function hideCardOverlay() {
            if (!isCardExpanded && document.getElementById('holographic-card').style.display === 'none') return;
            const card = document.getElementById('holographic-card');
            const btn = document.getElementById('show-card-btn');
            
            gsap.to(card, { 
                opacity: 0, 
                scale: 0.8, 
                duration: 0.4, 
                onComplete: () => {
                    card.style.display = 'none';
                    card.style.pointerEvents = 'none';
                    isCardExpanded = false;
                    btn.style.display = 'block';
                }
            });
        }

        function showCardOverlay() {
            const card = document.getElementById('holographic-card');
            const btn = document.getElementById('show-card-btn');
            
            card.style.display = 'flex';
            card.style.pointerEvents = 'auto';
            isCardExpanded = true;
            btn.style.display = 'none';
            autoRotate = false;

            gsap.fromTo(card, { opacity: 0, scale: 0.5 }, { opacity: 1, scale: 1, duration: 0.4, ease: "back.out(1.2)" });
        }

        function interactTriggered() {
            hideCardOverlay();
            lastInteractTime = Date.now();
            autoRotate = false;
        }

        function snapToIndex(delta) {
            hideCardOverlay();
            const count = config.photoList.length;
            const step = (Math.PI * 2) / count;
            currentPhotoIndex += delta;
            targetRotation = currentPhotoIndex * -step;
            gsap.to(galleryGroup.rotation, { y: targetRotation, duration: 0.8, ease: "power2.out" });
        }

        /**
         * å‡çº§åçš„æ‰‹åŠ¿è¯†åˆ«ï¼šæŒ¥æ‰‹æ—‹è½¬ã€æåˆé€‰ä¸­ã€æ”¾å¤§ç¼©å°ã€æ¡æ‹³é‡ç½®
         */
function dist2(a, b) {
  const dx = a.x - b.x, dy = a.y - b.y;
  return Math.hypot(dx, dy);
}

// æ›´ç¨³çš„â€œå¼ å¼€/åˆæ‹¢â€åˆ¤å®šï¼šæŒ‡å°–åˆ°æŒå¿ƒè·ç¦»ï¼ˆå½’ä¸€åŒ–ï¼‰
function getPalmCenter(lm) {
  // wrist(0), index_mcp(5), pinky_mcp(17) çš„å¹³å‡ä½œä¸ºæŒå¿ƒä¸­å¿ƒ
  return {
    x: (lm[0].x + lm[5].x + lm[17].x) / 3,
    y: (lm[0].y + lm[5].y + lm[17].y) / 3
  };
}

function isOpenPalmByDistance(lm) {
  const pc = getPalmCenter(lm);
  const palmSize = dist2(lm[0], lm[9]); // wrist(0)åˆ°middle_mcp(9)ä½œä¸ºå°ºåº¦
  const tips = [4, 8, 12, 16, 20];
  // å¤§å¤šæ•°æŒ‡å°–ç¦»æŒå¿ƒè¶³å¤Ÿè¿œ => å¼ å¼€
  const farCount = tips.filter(i => dist2(lm[i], pc) / palmSize > 0.85).length;
  return farCount >= 4;
}

function isFistByDistance(lm) {
  const pc = getPalmCenter(lm);
  const palmSize = dist2(lm[0], lm[9]);
  const tips = [4, 8, 12, 16, 20];
  // å¤§å¤šæ•°æŒ‡å°–é è¿‘æŒå¿ƒ => åˆæ‹¢
  const nearCount = tips.filter(i => dist2(lm[i], pc) / palmSize < 0.55).length;
  return nearCount >= 4;
}

// ç”¨é£ŸæŒ‡æŒ‡å°–åšæ‹¾å–ï¼ˆæä½é€‰å–ï¼‰
function pickCardByIndexTip(lm) {
  // mediapipe x,y in [0,1]
  const x = lm[8].x;
  const y = lm[8].y;
  ndcHand.set(x * 2 - 1, -(y * 2 - 1));
  raycasterHand.setFromCamera(ndcHand, camera);

  // intersect photoCardsï¼ˆgroupï¼‰è¦ç”¨ trueï¼Œå‘½ä¸­å†…éƒ¨ mesh
  const hits = raycasterHand.intersectObjects(photoCards, true);
  if (!hits || hits.length === 0) return null;

  // å›æº¯åˆ° photoCards ä¸­çš„ group
  let obj = hits[0].object;
  while (obj && !photoCards.includes(obj) && obj.parent) obj = obj.parent;
  return photoCards.includes(obj) ? obj : null;
}

function focusCard(card) {
  if (!card) return;

  // å¦‚æœåˆ‡æ¢é€‰ä¸­ï¼Œå…ˆæ”¾å›æ—§çš„
  if (selectedCard && selectedCard !== card) unfocusCard();

  if (!selectedCard) {
    selectedCard = card;
    selectedHome = {
      pos: card.position.clone(),
      scale: card.scale.clone(),
    };
  }

  // æŠŠå¡ç‰‡æ‹‰åˆ°â€œçƒä½“å‰æ–¹â€å¹¶æ”¾å¤§ï¼ˆåœ¨ galleryGroup çš„å±€éƒ¨åæ ‡ç³»é‡Œæ“ä½œï¼‰
  // ç›®æ ‡ï¼šé è¿‘ç›¸æœºè§†çº¿æ–¹å‘çš„ä¸€ç‚¹ç‚¹ï¼ˆæ•ˆæœï¼šå‰æ™¯æ”¾å¤§ï¼‰
  const camDir = new THREE.Vector3();
  camera.getWorldDirection(camDir);
  const targetWorld = camera.position.clone().add(camDir.multiplyScalar(1.15));
  const targetLocal = galleryGroup.worldToLocal(targetWorld.clone());

  gsap.to(card.position, { x: targetLocal.x, y: targetLocal.y, z: targetLocal.z, duration: 0.35, ease: "power3.out" });
  gsap.to(card.scale, { x: 1.85, y: 1.85, z: 1, duration: 0.35, ease: "power3.out" });

  // è¾¹æ¡†æ›´äº®ä¸€ç‚¹
  if (card.children && card.children[1] && card.children[1].material) {
    gsap.to(card.children[1].material, { opacity: 0.85, duration: 0.25, overwrite: true });
  }
}

	function unfocusCard() {
  	   if (!selectedCard || !selectedHome) return;
 	 const card = selectedCard;

  	gsap.to(card.position, { x: selectedHome.pos.x, y: selectedHome.pos.y, z: selectedHome.pos.z, duration: 0.45, ease: "power2.out" });
  	gsap.to(card.scale, { x: selectedHome.scale.x, y: selectedHome.scale.y, z: selectedHome.scale.z, duration: 0.45, ease: "power2.out" });

  	if (card.children && card.children[1] && card.children[1].material) {
   	 gsap.to(card.children[1].material, { opacity: 0.3, duration: 0.25, overwrite: true });
 	   }

  	selectedCard = null;
  	selectedHome = null;
	   }

        /**
 * æ‰‹åŠ¿äº¤äº’ï¼ˆä»…æ”¹è¿™ä¸€éƒ¨åˆ†ï¼‰ï¼š
 * 1) å·¦å³æŒ¥æ‰‹ï¼šè¿ç»­æ—‹è½¬æ˜Ÿè¾‰çƒï¼ˆgalleryGroup.rotation.yï¼‰
 * 2) æåˆï¼šé€‰å–ç…§ç‰‡å¹¶æ‹‰åˆ°å‰æ™¯æ”¾å¤§ï¼ˆæ¾å¼€åˆ™å›ä½ï¼‰
 * 3) å¼ å¼€æ‰‹æŒï¼šæ”¾å¤§ï¼ˆç›¸æœºæ‹‰è¿‘ + ç›¸å†Œå¾®æ”¾å¤§ï¼‰
 *    åˆæ‹¢æ‰‹æŒï¼ˆæ¡æ‹³ï¼‰ï¼šç¼©å›â€œè›‹ç³•çŠ¶â€ï¼ˆç›¸å†Œç¼©å°éšè— + è›‹ç³•å›åˆ°1ï¼‰
 */
function onHandResults(results) {
if (isCardExpanded) return;
  if (currentState !== State.CARD_PHOTOS || !results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
    pinchHold = 0; palmHold = 0; fistHold = 0;
    return;
  }

  // ä¸€æ—¦å¼€å§‹äº¤äº’å°±å…³é—­è´ºå¡ï¼ˆä½ è¦æ±‚äº’åŠ¨æ—¶å…³é—­ï¼‰
  interactTriggered();

  const lm = results.multiHandLandmarks[0];
  const now = Date.now();

  const wrist = lm[0];
  const middleMcp = lm[9];
  const thumbTip = lm[4];
  const indexTip = lm[8];

  // -------- 1) è¿ç»­æ—‹è½¬ï¼šç”¨æ‰‹çš„æ°´å¹³ç§»åŠ¨é©±åŠ¨æ—‹è½¬ï¼ˆæ›´åƒâ€œå°çº¢ä¹¦é‚£ç§è·Ÿæ‰‹â€ï¼‰--------
  // ç”¨ middleMcp.xï¼ˆæ¯” wrist æ›´ç¨³ï¼‰è®¡ç®— dxï¼Œå¹¶åšä¸€ç‚¹å¹³æ»‘ï¼Œé¿å…æŠ–åŠ¨
  const handX = middleMcp.x;
  if (lastWristX !== 0) {
    const dx = handX - lastWristX; // æ­£=å‘å³ç§»åŠ¨
    // å¹³æ»‘ + æ­»åŒº
    smoothedDx = smoothedDx * 0.75 + dx * 0.25;
    const dead = 0.0035;
    if (Math.abs(smoothedDx) > dead && !isPinching) {
      galleryGroup.rotation.y += smoothedDx * config.gesture.swipeSensitivity * 6.0;
    }
  }
  lastWristX = handX;

  // -------- 2) æåˆé€‰å–æ”¾å¤§ï¼špinchNorm = dist(4,8) / dist(0,9) --------
  const d48 = dist2(thumbTip, indexTip);
  const d09 = dist2(wrist, middleMcp);
  const pinchNorm = d48 / Math.max(1e-6, d09);

  const pinchEnter = 0.42;  // è¿›å…¥æåˆï¼ˆæ›´ç¨³ï¼‰
  const pinchExit  = 0.55;  // é€€å‡ºæåˆ

  if (pinchNorm < pinchEnter) {
    isPinching = true;
    pinchHold++;

    // æåˆä¿æŒåˆ°ä¸€å®šå¸§æ•°æ‰è§¦å‘â€œé€‰ä¸­â€ï¼Œé¿å…æŠ–åŠ¨è¯¯é€‰
    if (pinchHold === config.gesture.kFrames) {
      const hit = pickCardByIndexTip(lm);
      if (hit) focusCard(hit);
    }

    // pinch æœŸé—´å…è®¸è½»å¾®æ‹‰è¿‘ï¼ˆå¯é€‰ï¼Œç»™â€œæåˆ=æ›´è¿‘æ›´å¤§â€çš„æ„Ÿè§‰ï¼‰
    const targetZ = THREE.MathUtils.mapLinear(
      THREE.MathUtils.clamp(pinchNorm, 0.18, pinchEnter),
      0.18, pinchEnter,
      5.2, 6.6
    );
    camera.position.z += (targetZ - camera.position.z) * 0.18;

  } else if (pinchNorm > pinchExit) {
    // æ¾å¼€æåˆï¼šå–æ¶ˆé€‰ä¸­å¹¶å›ä½
    isPinching = false;
    pinchHold = 0;
    unfocusCard();
  }

  // -------- 3) å¼ å¼€/åˆæ‹¢ï¼šå¼ å¼€=æ”¾å¤§ï¼›åˆæ‹¢=ç¼©å›è›‹ç³•çŠ¶ --------
  const openPalm = isOpenPalmByDistance(lm);
  const fist = isFistByDistance(lm);

  // å¼ å¼€æ‰‹æŒï¼šæ”¾å¤§ï¼ˆç›¸æœºæ›´è¿‘ + ç›¸å†Œè½»å¾®æ”¾å¤§ï¼‰
  if (openPalm && !fist && !isPinching) {
    palmHold++;
    if (palmHold >= config.gesture.kFrames && !isPalmZoomed) {
      isPalmZoomed = true;
      gsap.to(camera.position, { z: 5.2, duration: 0.45, ease: "power2.out", overwrite: true });
      gsap.to(galleryGroup.scale, { x: 1.08, y: 1.08, z: 1.08, duration: 0.45, ease: "power2.out", overwrite: true });
      palmHold = 0;
    }
  } else {
    palmHold = 0;
  }

  // åˆæ‹¢æ‰‹æŒï¼ˆæ¡æ‹³ï¼‰ï¼šç¼©å›æœ€å¼€å§‹è›‹ç³•çŠ¶ï¼ˆä¸ reloadï¼‰
  if (fist) {
    fistHold++;
    if (fistHold >= Math.max(10, config.gesture.kFrames * 2)) {
      fistHold = 0;

      // å…ˆæ”¾å›é€‰ä¸­çš„ç…§ç‰‡
      unfocusCard();

      // ç›¸å†Œç¼©å°éšè— + è›‹ç³•å›åˆ° 1ï¼ˆâ€œè›‹ç³•çŠ¶â€ï¼‰
      autoRotate = false;
      isPalmZoomed = false;

      gsap.to(galleryGroup.scale, { x: 0.05, y: 0.05, z: 0.05, duration: 0.75, ease: "expo.inOut" });
      gsap.to(camera.position, { z: 6.5, y: 1.8, duration: 0.75, ease: "power2.out" });

      // æŠŠè›‹ç³•æ‹‰å›ï¼ˆä½ çš„ cakeGroup ä¹‹å‰è¢«ç¼©åˆ°0ï¼Œè¿™é‡Œæ¢å¤ï¼‰
      if (cakeGroup) gsap.to(cakeGroup.scale, { x: 1, y: 1, z: 1, duration: 0.85, ease: "expo.out" });

      // ç»™ç”¨æˆ·ä¸€ä¸ªâ€œç¼©å›è›‹ç³•â€çš„æ„Ÿå—ï¼šæç¤ºæ·¡å‡º
      document.getElementById('gallery-hint').style.opacity = 0.0;
    }
  } else {
    fistHold = 0;
  }

  // è‹¥ç”¨æˆ·ä»å¼ å¼€æ€é€€å‡ºï¼ˆä¸æ˜¯å¼ å¼€äº†ï¼‰ï¼Œå›åˆ°é»˜è®¤ç›¸å†Œå¤§å°ï¼ˆä¸å½±å“å…¶å®ƒé€»è¾‘ï¼‰
  if (!openPalm && isPalmZoomed && !isPinching) {
    // è½»å¾®å›å¼¹åˆ°é»˜è®¤
    isPalmZoomed = false;
    gsap.to(camera.position, { z: 7.0, duration: 0.45, ease: "power2.out", overwrite: true });
    gsap.to(galleryGroup.scale, { x: 1.0, y: 1.0, z: 1.0, duration: 0.45, ease: "power2.out", overwrite: true });
  }
}


        function triggerShrinkToCake() {
            if (currentState !== State.CARD_PHOTOS) return;
            
            const tl = gsap.timeline({
                onComplete: () => {
                    if (mpCamera) mpCamera.stop();
                    location.reload(); // å½»åº•é‡ç½®
                }
            });

            // åŠ¨ç”»ï¼šæ˜Ÿçƒå’Œç›¸ç‰‡è¿…é€Ÿç¼©å°å¹¶æ¶ˆå¤±
            tl.to(galleryGroup.scale, { x: 0, y: 0, z: 0, duration: 0.8, ease: "power2.in" });
            tl.to(camera.position, { z: 10, duration: 0.8 }, 0);
            tl.to(document.body, { opacity: 0, duration: 0.5 }, 0.5);
        }

        function createCake() {
            cakeGroup = new THREE.Group();
            const bottom = createPointLayer(1.3, 0.9, 5000, "#6622aa"); bottom.position.y = -0.5;
            const top = createPointLayer(0.8, 0.7, 3000, "#ffffff"); top.position.y = 0.3;
            cakeGroup.add(bottom, top);
            const configs = [{x:-0.38, y:0.85, s:0.85}, {x:0, y:1.05, s:1.0}, {x:0.38, y:0.85, s:0.85}];
            configs.forEach(cfg => {
                const candle = createCandle(cfg.s);
                candle.position.set(cfg.x, cfg.y, 0.1);
                cakeGroup.add(candle);
                candles.push(candle);
            });
            cakeGroup.position.y = 0.6;
            cakeGroup.scale.set(0,0,0);
            scene.add(cakeGroup);
        }

        function createCandle(scale) {
            const g = new THREE.Group(); g.scale.set(scale, scale, scale);
            const bodyGeo = new THREE.CylinderGeometry(0.045, 0.05, 0.58, 16);
            const pos = bodyGeo.attributes.position;
            const colors = new Float32Array(pos.count * 3);
            const cBot = new THREE.Color(config.theme.rosePink);
            const cTop = new THREE.Color(config.theme.lavender);
            for(let i=0; i<pos.count; i++) {
                const mixed = cBot.clone().lerp(cTop, (pos.getY(i)+0.29)/0.58);
                colors[i*3]=mixed.r; colors[i*3+1]=mixed.g; colors[i*3+2]=mixed.b;
            }
            bodyGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            g.add(new THREE.Mesh(bodyGeo, new THREE.MeshBasicMaterial({ vertexColors:true, transparent:true, opacity:0.9 })));
            const f = createFlame(); f.position.y = 0.34;
            g.add(f); flames.push(f);
            return g;
        }

        function createFlame() {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(40*3); geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            const pts = new THREE.Points(geo, new THREE.PointsMaterial({ size: 0.08, color: 0xffffff, transparent: true, blending: THREE.AdditiveBlending }));
            pts.userData = { speeds: Array.from({length:40}, ()=>Math.random()*0.015+0.01) };
            return pts;
        }

        function createPointLayer(r, h, c, col) {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(c*3);
            for(let i=0; i<c; i++){
                const ang = Math.random()*Math.PI*2;
                const dist = Math.sqrt(Math.random())*r;
                pos[i*3]=dist*Math.cos(ang); pos[i*3+1]=(Math.random()-0.5)*h; pos[i*3+2]=dist*Math.sin(ang);
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            return new THREE.Points(geo, new THREE.PointsMaterial({ size: 0.03, color: col, transparent: true, opacity:0.7, blending: THREE.AdditiveBlending }));
        }

        function createGiftBox() {
  const g = new THREE.Group();

  // ---------- 0) å°å·¥å…·ï¼šè®°å½•ç›®æ ‡é€æ˜åº¦ï¼Œæ–¹ä¾¿ revealGift åšæ·¡å…¥ ----------
  function setFadeTarget(obj) {
    obj.traverse((o) => {
      if (o.material) {
        // è®°å½•â€œåº”è¯¥æ·¡å…¥åˆ°å¤šå°‘â€
        o.userData.targetOpacity = (o.material.opacity ?? 1);
        // åˆå§‹å…¨é€æ˜
        o.material.transparent = true;
        o.material.opacity = 0;
        // é€æ˜ç‰©ä½“æ’åºæ›´ç¨³å®š
        o.material.depthWrite = false;
      }
    });
  }

  // ---------- 1) ç›’ä½“ï¼ˆçº¢è‰²ç£¨ç ‚ + ç›–å­ï¼‰ ----------
const boxBodyMat = new THREE.MeshStandardMaterial({
  color: 0xC9152C,
  roughness: 0.55,
  metalness: 0.15,
  transparent: true,
  opacity: 0.95
});
const boxLidMat = new THREE.MeshStandardMaterial({
  color: 0xE31D3B,
  roughness: 0.45,
  metalness: 0.20,
  transparent: true,
  opacity: 0.98
});

 

  // ç›’èº« + ç›–å­ï¼ˆç›–å­ç•¥å¤§ï¼Œç¨ä¸Šç§»ï¼‰
  const body = new THREE.Mesh(new THREE.BoxGeometry(0.92, 0.78, 0.92), boxBodyMat);
  body.position.y = -0.03;

  const lid = new THREE.Mesh(new THREE.BoxGeometry(0.98, 0.28, 0.98), boxLidMat);
  lid.position.y = 0.43;

  g.add(body, lid);

  // ---------- 2) æ¯›ç»’ç™½è¾¹ï¼ˆåœ£è¯æ„Ÿå…³é”®ï¼šé¡¶éƒ¨ä¸€åœˆâ€œfuzzy trimâ€ï¼‰ ----------
  const trimMat = new THREE.MeshBasicMaterial({
    color: 0xFFFFFF,
    transparent: true,
    opacity: 0.16
  });
  // ç”¨è–„ç›’å­æ‹¼ä¸€åœˆï¼ˆé¿å…è´´å›¾ï¼Œçº¯å‡ ä½•ï¼‰
  const t = 0.06; // trim åšåº¦
  const w = 0.98; // å¤–å®½
  const h = 0.10; // é«˜
  const z = 0.98;

  const trimFront = new THREE.Mesh(new THREE.BoxGeometry(w, h, t), trimMat); trimFront.position.set(0, 0.30,  z/2);
  const trimBack  = new THREE.Mesh(new THREE.BoxGeometry(w, h, t), trimMat); trimBack.position.set(0, 0.30, -z/2);
  const trimLeft  = new THREE.Mesh(new THREE.BoxGeometry(t, h, z), trimMat); trimLeft.position.set(-w/2, 0.30, 0);
  const trimRight = new THREE.Mesh(new THREE.BoxGeometry(t, h, z), trimMat); trimRight.position.set( w/2, 0.30, 0);
  g.add(trimFront, trimBack, trimLeft, trimRight);

  // ---------- 3) é‡‘è‰²ä¸å¸¦ï¼ˆåå­—è…°å° + é¡¶éƒ¨æ¨ªå¸¦ï¼‰ ----------
  const ribbonMat = new THREE.MeshBasicMaterial({
    color: 0xF7D36B,       // é‡‘è‰²
    transparent: true,
    opacity: 0.32
  });

  // ç«–å¸¦ï¼ˆè´¯ç©¿ç›’èº«+ç›–å­ï¼‰
  const ribbonV = new THREE.Mesh(new THREE.BoxGeometry(0.14, 1.05, 0.95), ribbonMat);
  ribbonV.position.y = 0.12;

  // æ¨ªå¸¦ï¼ˆè´¯ç©¿ç›’èº«+ç›–å­ï¼‰
  const ribbonH = new THREE.Mesh(new THREE.BoxGeometry(0.95, 1.05, 0.14), ribbonMat);
  ribbonH.position.y = 0.12;

  // é¡¶éƒ¨å†åŠ ä¸€æ¡æ¨ªå¸¦ï¼ˆæ›´åƒâ€œç›–å­ä¸Šçš„ä¸å¸¦â€ï¼‰
  const ribbonTop = new THREE.Mesh(new THREE.BoxGeometry(0.95, 0.08, 0.16), ribbonMat);
  ribbonTop.position.set(0, 0.57, 0);

  g.add(ribbonV, ribbonH, ribbonTop);

  // ---------- 4) ç«‹ä½“è´è¶ç»“ï¼ˆå››ä¸ªç¯ + ä¸¤æ¡å°¾å·´ + ç»“ç‚¹ï¼‰ ----------
  const bowMat = new THREE.MeshBasicMaterial({
    color: 0xF7D36B,
    transparent: true,
    opacity: 0.42
  });

  const ringGeo = new THREE.TorusGeometry(0.14, 0.045, 12, 28);
  const bow1 = new THREE.Mesh(ringGeo, bowMat.clone());
  const bow2 = new THREE.Mesh(ringGeo, bowMat.clone());
  const bow3 = new THREE.Mesh(ringGeo, bowMat.clone());
  const bow4 = new THREE.Mesh(ringGeo, bowMat.clone());

  bow1.rotation.set(Math.PI/2, 0, 0);
  bow2.rotation.set(Math.PI/2, Math.PI/2, 0);
  bow3.rotation.set(Math.PI/2, Math.PI/4, 0);
  bow4.rotation.set(Math.PI/2, -Math.PI/4, 0);

  // âœ… å…ˆåˆ›å»º knot / tailsï¼Œå†æ”¹ä½ç½®ï¼ˆä½ ç°åœ¨å°±æ˜¯å°‘äº†è¿™ä¸€æ­¥ï¼‰
  const knot = new THREE.Mesh(new THREE.SphereGeometry(0.07, 16, 16), bowMat.clone());

  const tailGeo = new THREE.BoxGeometry(0.10, 0.22, 0.04);
  const tailL = new THREE.Mesh(tailGeo, bowMat.clone());
  const tailR = new THREE.Mesh(tailGeo, bowMat.clone());

  // âœ… å†ç»Ÿä¸€è®¾ç½®ä½ç½®
  const bowY = 0.66;
  const bowZ = 0.62;

  bow1.position.set(0, bowY, bowZ);
  bow2.position.set(0, bowY, bowZ);
  bow3.position.set(0, bowY, bowZ);
  bow4.position.set(0, bowY, bowZ);

  knot.position.set(0, bowY, bowZ + 0.03);

  tailL.position.set(-0.08, 0.52, 0.60);
  tailR.position.set( 0.08, 0.52, 0.60);
  tailL.rotation.set(0.2, 0.2,  0.25);
  tailR.rotation.set(0.2,-0.2, -0.25);

  [bow1,bow2,bow3,bow4,knot,tailL,tailR].forEach((m,i)=>{ m.renderOrder = 20 + i; });

  g.add(bow1, bow2, bow3, bow4, knot, tailL, tailR);


  // ---------- 5) æ˜Ÿè¾‰ç²’å­ï¼ˆå°‘é‡ã€å›´ç»•ç›’å­ï¼Œä¸è¦â€œé›ªå™ªç‚¹â€ï¼‰ ----------
  const pCount = 220;
  const pGeo = new THREE.BufferGeometry();
  const pPos = new Float32Array(pCount * 3);
  for (let i = 0; i < pCount; i++) {
    // åœ¨ç›’å­å‘¨å›´ä¸€ä¸ªâ€œæ¤­çƒå£³â€ä¸Šé‡‡æ ·ï¼ˆæ›´åƒå…‰æ™•ï¼‰
    const u = Math.random() * Math.PI * 2;
    const v = Math.acos(Math.random() * 2 - 1);
    const r = 0.75 + Math.random() * 0.20;
    const x = r * Math.sin(v) * Math.cos(u);
    const y = r * Math.sin(v) * Math.sin(u) * 0.85 + 0.10;
    const z2 = r * Math.cos(v);
    pPos[i*3] = x;
    pPos[i*3+1] = y;
    pPos[i*3+2] = z2;
  }
  pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));

  const sparkle = new THREE.Points(
    pGeo,
    new THREE.PointsMaterial({
      size: 0.02,
      color: 0xFFFFFF,
      transparent: true,
      opacity: 0.22,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    })
  );
  sparkle.renderOrder = 5;
  g.add(sparkle);

  // ---------- 6) æ ¸å¿ƒæ˜Ÿè¾‰ï¼ˆä¿æŒä½ åŸæ¥çš„é€»è¾‘ï¼‰ ----------
  const core = new THREE.Mesh(
    new THREE.SphereGeometry(0.18, 16, 16),
    new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.0 })
  );
  g.add(core);
  g.userData.core = core;

  // ---------- 7) é€æ˜ç¢°æ’ç›’ï¼ˆç‚¹å‡»å‘½ä¸­æ›´ç¨³ï¼šä½ ç°æœ‰ç‚¹å‡»é€»è¾‘éœ€è¦ï¼‰ ----------
  const collider = new THREE.Mesh(
    new THREE.BoxGeometry(1.20, 1.10, 1.20),
    new THREE.MeshBasicMaterial({ transparent: true, opacity: 0.0, depthWrite: false })
  );
  collider.name = "giftCollider";
  collider.renderOrder = 100;
  g.add(collider);
  g.userData.collider = collider;

  // ---------- 8) ä½œä¸º giftBox ä½¿ç”¨ ----------
  giftBox = g;
  giftBox.position.set(0, 1.2, 0.5);
  giftBox.scale.set(0.95, 0.95, 0.95);

  // åˆå§‹ä¸å¯è§ï¼ˆé…åˆ revealGift æ·¡å…¥ï¼‰
  setFadeTarget(giftBox);
 
  scene.add(giftBox);
}


        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
                    const source = audioContext.createMediaStreamSource(stream);
                    analyser = audioContext.createAnalyser(); analyser.fftSize = 256;
                    source.connect(analyser); dataArray = new Uint8Array(analyser.frequencyBinCount);
                }).catch(() => document.getElementById('skip-btn').style.display = 'block');
            } catch(e) {}
        }

        function initInteractionListeners() {
            const container = document.getElementById('canvas-container');
            container.addEventListener('click', (e) => {
                if(currentState === State.GIFT) {
                    const mouse = new THREE.Vector2((e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1);
                    const raycaster = new THREE.Raycaster();
                    raycaster.setFromCamera(mouse, camera);
                    const target = (giftBox && giftBox.userData && giftBox.userData.collider) ? giftBox.userData.collider : giftBox;
if (target && raycaster.intersectObject(target, true).length > 0) openGift();
                }
            });
            container.addEventListener('mousedown', (e) => { 
                if(currentState === State.CARD_PHOTOS) { 
                    hideCardOverlay();
                    isDragging = true; startX = e.clientX; interactTriggered(); 
                } 
            });
            window.addEventListener('mousemove', (e) => {
                if(isDragging && currentState === State.CARD_PHOTOS) {
                    const deltaX = e.clientX - startX;
                    galleryGroup.rotation.y += deltaX * 0.005;
                    startX = e.clientX;
                }
            });
            window.addEventListener('mouseup', () => { if(isDragging) { isDragging = false; snapToIndex(0); } });
            window.addEventListener('keydown', (e) => {
                if(currentState === State.CARD_PHOTOS) {
                    if(e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
                        interactTriggered();
                        if(e.key === 'ArrowRight') snapToIndex(1); else snapToIndex(-1);
                    }
                }
            });
            window.addEventListener('wheel', (e) => {
                if(currentState === State.CARD_PHOTOS) { 
                    interactTriggered(); 
                    camera.position.z = Math.min(Math.max(camera.position.z + e.deltaY * 0.005, 5), 12); 
                }
            });
        }

        async function startSequence() {
		const bgm = document.getElementById('bgm');
 		 if (bgm) {
    		bgm.volume = 0.6;
    		bgm.play().catch(()=>{});
  		}

            initThree();
            document.getElementById('intro-screen').style.display = 'none';
            setState(State.COUNTDOWN);
            const cd = document.getElementById('countdown');
            cd.style.display = 'block';
            for(let i=3; i>0; i--) {
                cd.innerText = i;
                gsap.fromTo(cd, {scale: 0.3, opacity: 0}, {scale: 1.1, opacity: 1, duration: 0.7, ease: "back.out"});
                await new Promise(r => setTimeout(r, 1000));
            }
            cd.style.display = 'none';
            revealCake();
        }

        function revealCake() {
            setState(State.CAKE_REVEAL);
            createCake(); createGiftBox(); createPhotoGallery();
            document.getElementById('title').style.opacity = 1;
            gsap.to(cakeGroup.scale, { x: 1, y: 1, z: 1, duration: 2.5, ease: "expo.out" });
            setTimeout(() => { initAudio(); startBlowStage(); }, 2600);
        }

        function startBlowStage() {
            setState(State.BLOW);
            document.getElementById('blow-meter').style.display = 'block';
            document.getElementById('status-msg').innerText = "å¯¹ç€éº¦å…‹é£æ·±å‘¼å¸ï¼Œä¸€å£æ°”å¹ç­å®ƒä»¬";
            setTimeout(() => { if(currentState === State.BLOW) document.getElementById('skip-btn').style.display = 'block'; }, 9000);
        }

        function finishBlowing() {
            if(currentState !== State.BLOW) return;
            setState(State.EXTINGUISH);
            document.getElementById('interaction-ui').style.display = 'none';
            const tl = gsap.timeline();
            tl.to(flames[1].scale, { x: 0, y: 0, z: 0, duration: 0.6 });
            tl.to([flames[0].scale, flames[2].scale], { x: 0, y: 0, z: 0, duration: 0.8 }, "-=0.2");
            setTimeout(revealGift, 1500);
        }

        function revealGift() {
  setState(State.GIFT);

 giftBox.traverse(obj => {
   if (obj.material) {
     const t = (obj === giftBox.userData.core) ? 0.8 : (obj.userData.targetOpacity ?? 0.85);
     gsap.to(obj.material, { opacity: t, duration: 1 });
   }
});

  gsap.to(giftBox.position, { y: 1.5, repeat: -1, yoyo: true, duration: 2, ease: "sine.inOut" });

  document.getElementById('status-msg').style.display = 'block';
  document.getElementById('status-msg').innerText = "æ˜Ÿå…‰å‡ç»“æˆäº†ç¤¼ç‰©ï¼Œç‚¹å‡»æ‰“å¼€å®ƒ";
}

async function openGift() {
  if(currentState !== State.GIFT) return;
  setState(State.CARD_PHOTOS);

  // å…ˆè®©å¯¹æ–¹é€‰ç…§ç‰‡ï¼ˆä¸é€‰å°±ä¸è¿›å…¥ç›¸å†Œï¼‰
  let urls = [];
  try {
    document.getElementById('status-msg').style.display = 'block';
    document.getElementById('status-msg').innerText = "è¯·é€‰æ‹©è¦å±•ç¤ºçš„ç…§ç‰‡ï¼ˆä»…æœ¬åœ°æ˜¾ç¤ºï¼Œä¸ä¼šä¸Šä¼ ï¼‰";

    urls = await requestLocalPhotos();
  } catch (e) {
    // ç”¨æˆ·å–æ¶ˆé€‰æ‹©ï¼šå›åˆ°ç¤¼ç‰©é˜¶æ®µï¼Œä¸ç»§ç»­
    setState(State.GIFT);
    document.getElementById('status-msg').innerText = "æœªé€‰æ‹©ç…§ç‰‡ï¼Œå¯å†æ¬¡ç‚¹å‡»ç¤¼ç‰©æ‰“å¼€";
    return;
  }

  // æŠŠæœ¬åœ° URLs å¡å›é…ç½®ï¼Œå¤ç”¨ä½ åŸæ¥çš„å»ºç›¸å†Œé€»è¾‘
  config.photoList = urls;

  // å¦‚æœä¹‹å‰åˆ›å»ºè¿‡ç›¸å†Œï¼Œå…ˆæ¸…æ‰é‡å»º
  disposeGallery();
  createPhotoGallery();

  // ä¸‹é¢ä¿æŒä½ åŸé€»è¾‘
  burstStars(giftBox.position);
  scene.remove(giftBox);
  gsap.to(cakeGroup.scale, { x:0, y:0, z:0, duration: 1 });

  galleryGroup.visible = true;
  galleryGroup.scale.set(0.1, 0.1, 0.1);
  gsap.to(galleryGroup.scale, { x:1, y:1, z:1, duration: 1.5, ease: "expo.out" });
  gsap.to(camera.position, { z: 7.0, y: 1.5, duration: 2 });

  showCardOverlay();
  document.getElementById('gallery-hint').style.opacity = 1;
  document.getElementById('status-msg').innerText = ""; // æ¸…æç¤º
    // ç§»åŠ¨ç«¯éœ€è¦â€œç¬¬äºŒæ¬¡æ˜ç¡®ç‚¹å‡»â€æ‰èƒ½ç¨³å®šå¼¹å‡ºç›¸æœºæƒé™
  const btn = document.getElementById('enable-hands-btn');
  if (btn) btn.style.display = 'inline-block';

  const hint = document.getElementById('gallery-hint');
  if (hint) hint.innerText = "ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¯ç”¨æ‰‹åŠ¿äº’åŠ¨ï¼›æŒ¥æ‰‹æ—‹è½¬æ˜Ÿçƒï¼Œæåˆç¼©æ”¾ç…§ç‰‡";
}
   
  let handsStarted = false;

function enableHandsFromUserGesture() {
  // å¿…é¡»ç”±ç”¨æˆ·ç‚¹å‡»è§¦å‘ï¼ˆç§»åŠ¨ç«¯ç›¸æœºæƒé™æ›´ç¨³ï¼‰
  startHands();
  const btn = document.getElementById('enable-hands-btn');
  if (btn) btn.style.display = 'none';
}

        function startHands() {
         if (handsStarted) return;
            handsStarted = true;

            const videoElement = document.getElementById('input-video');
            mpHands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            mpHands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            mpHands.onResults(onHandResults);
            mpCamera = new Camera(videoElement, { onFrame: async () => { await mpHands.send({image: videoElement}); }, width: 640, height: 480 });
            mpCamera.start().catch((err) => {
  console.log("mpCamera start failed:", err);
  const hint = document.getElementById('gallery-hint');
  if (hint) {
    hint.style.opacity = 1;
    hint.innerText = "æ‰‹åŠ¿ä¸å¯ç”¨ï¼šç›¸æœºæƒé™æœªå¼€å¯æˆ–è¢«æµè§ˆå™¨æ‹¦æˆªã€‚è¯·ç‚¹å‡»â€œå¯ç”¨æ‰‹åŠ¿äº’åŠ¨â€å¹¶å…è®¸ç›¸æœºæƒé™ã€‚";
  }
  handsStarted = false; // å…è®¸ç”¨æˆ·å†æ¬¡ç‚¹å‡»æŒ‰é’®é‡è¯•
});
        }

   function restartPage() { 
  if (mpCamera) mpCamera.stop(); 
  revokeLocalPhotoURLs();
  location.reload(); 
}


        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            if(starField) starField.rotation.y += 0.0005;

            if(galleryGroup && galleryGroup.visible) {
                if(autoRotate && !isCardExpanded) galleryGroup.rotation.y += 0.002;
                else if(Date.now() - lastInteractTime > 5000 && !isCardExpanded) autoRotate = true;

                sphereParticles.rotation.y += 0.001;

                photoCards.forEach((card) => {
  card.lookAt(camera.position);

  // è¢«é€‰ä¸­çš„å¡ç‰‡ç”± focusCard() æ§åˆ¶ï¼Œä¸åœ¨è¿™é‡ŒåŠ¨å®ƒ
  if (selectedCard === card) return;

  // å›ºå®šå°ºå¯¸ï¼šä¸è¦åŠ¨ scaleï¼ˆæˆ–è€…å¼ºåˆ¶è®¾å› 1ï¼‰
  card.scale.set(1, 1, 1);

  // å¯é€‰ï¼šåªåšæ·¡å…¥æ·¡å‡ºï¼Œè®©è¿œå¤„æ›´è½»
  const worldPos = new THREE.Vector3();
  card.getWorldPosition(worldPos);
  const dist = worldPos.distanceTo(camera.position);

  const a = THREE.MathUtils.clamp(1.0 - (dist - 4.5) / 5.5, 0.35, 1.0);
  card.children[0].material.opacity = a;
  card.children[1].material.opacity = 0.15 + a * 0.35;
});
            }

            flames.forEach(f => {
                const pos = f.geometry.attributes.position.array;
                for(let i=0; i<40; i++){ pos[i*3+1] += f.userData.speeds[i]; if(pos[i*3+1] > 0.35) pos[i*3+1] = 0; }
                f.geometry.attributes.position.needsUpdate = true;
            });

            if(currentState === State.BLOW) updateBlowDetection();
            if(renderer && scene && camera) renderer.render(scene, camera);
        }

        function updateBlowDetection() {
            if(!analyser) return;
            analyser.getByteFrequencyData(dataArray);
            let sum = 0; for(let i=0; i<8; i++) sum += dataArray[i];
            let avg = sum / 8 / 255;
            if(avg > config.blowThreshold) {
                blowProgress += 0.03;
                flames.forEach(f => f.scale.set(1+avg*2.5, 1+avg*2.5, 1+avg*2.5));
            } else { blowProgress = Math.max(0, blowProgress - 0.01); }
            document.getElementById('blow-fill').style.width = (blowProgress*100/config.blowHoldSeconds) + "%";
            if(blowProgress >= config.blowHoldSeconds) finishBlowing();
        }

        function burstStars(pos) {
            const count = 150;
            const geo = new THREE.BufferGeometry();
            const posArr = new Float32Array(count*3);
            for(let i=0; i<count*3; i++) posArr[i] = 0;
            geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
            const mat = new THREE.PointsMaterial({ size: 0.08, color: 0xffffff, blending: THREE.AdditiveBlending, transparent:true });
            const pts = new THREE.Points(geo, mat);
            pts.position.copy(pos); scene.add(pts);
            const vels = Array.from({length:count}, ()=>new THREE.Vector3((Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3));
            gsap.to({}, { duration: 1.5, onUpdate: () => {
                for(let i=0; i<count; i++){ posArr[i*3]+=vels[i].x; posArr[i*3+1]+=vels[i].y; posArr[i*3+2]+=vels[i].z; }
                pts.geometry.attributes.position.needsUpdate = true; pts.material.opacity -= 0.015;
            }, onComplete: () => scene.remove(pts) });
        }

        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function setState(s) { currentState = s; }
        function forceBlowDone() { gsap.to({v:blowProgress}, { v:config.blowHoldSeconds, duration:1.5, onUpdate:function(){ document.getElementById('blow-fill').style.width=(this.targets()[0].v*100/config.blowHoldSeconds)+"%"; }, onComplete:finishBlowing }); }

function fillCardText() {
  // To
  const toEl = document.getElementById('card-to');
  if (toEl) toEl.textContent = `To: ${config.recipientName}`;

  // Wish
  const wishEl = document.getElementById('card-wish');
  if (wishEl) {
    wishEl.innerHTML = config.messageLines.map(line => `<p style="margin:10px 0;">${line}</p>`).join('');
  }

  // Date
  const dateEl = document.getElementById('current-date');
  if (dateEl) dateEl.textContent = new Date().toLocaleDateString('zh-CN');
}

     window.onload = () => { 
  initThree(); 
  fillCardText();   // âœ… åŠ è¿™ä¸€å¥
  animate(); 
};
    </script>
</body>
</html>